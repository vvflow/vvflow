#!/usr/bin/env python3

from __future__ import print_function
from dataclasses import dataclass
from datetime import datetime
from enum import auto, Enum
from subprocess import Popen, PIPE
import argparse
import asyncio
import errno
import logging
import os
import signal

from rich import box
from rich.console import Console, Group
from rich.highlighter import NullHighlighter
from rich.live import Live
from rich.logging import RichHandler
from rich.table import Table


def parse_args():
    parser = argparse.ArgumentParser(
        prog='vvmon',
        description='Monitor simulation progress',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        'workdir',
        nargs='?',
        default='.',
        help='Simulation working directory to monitor'
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help='Print debug logs'
    )

    parser.add_argument(
        '-A, --all-columns',
        dest='all_columns',
        action='store_true',
        help='Output all columns'
    )

    return parser.parse_args()


@dataclass
class SimulationProgress():
    caption: str
    wallclock_time: datetime
    simulation_time: str | None
    simulation_percent: str | None
    vortex_count: str | None
    elapsed: str | None
    remains: str | None
    eta: str | None
    step_duration: str | None


class UnixConnection():
    class State(Enum):
        disconnected = auto()
        connected = auto()
        finished = auto()

    def __init__(self, sock_path, ev_updated):
        self.sock_path = sock_path
        self.finished = False
        self.last_error = None
        self.last_progress = None
        self.state = UnixConnection.State.disconnected
        self.ev_updated = ev_updated

    @staticmethod
    def decode_message(msg):
        ret = {}
        global log
        for field in msg.decode().split('\n'):
            if not '=' in field:
                continue
            key, val = field.split('=', 1)
            ret[key.strip()] = val.strip()
        return ret

    async def handle(self):
        global log
        log.debug(f'{self.sock_path}: Connecting...')
        while True:
            try:
                sock_reader, sock_writer = await asyncio.open_unix_connection(self.sock_path)
                log.debug(f'{self.sock_path}: Connected')
                self.state = UnixConnection.State.connected
                self.last_error = None
                self.last_progress = None
                self.ev_updated.set()
                while True:
                    msg = await sock_reader.read(1024)
                    if not len(msg):
                        sock_writer.close()
                        raise OSError(errno.ECONNRESET, "Connection reset by peer")
                    try:
                        keyval = UnixConnection.decode_message(msg)
                    except Exception as e:
                        log.warning(e)
                        continue
                    self.last_progress = SimulationProgress(
                        caption=self.sock_path,
                        wallclock_time=datetime.now(),
                        simulation_time=keyval.get('simulation_time'),
                        simulation_percent=keyval.get('percent'),
                        vortex_count=keyval.get('vortex_count'),
                        elapsed=keyval.get('elapsed'),
                        remains=keyval.get('remains'),
                        eta=keyval.get('eta'),
                        step_duration=keyval.get('step_duration'),
                    )
                    self.ev_updated.set()
            except FileNotFoundError as e:
                log.debug(f'{self.sock_path}: {e.strerror} (Error {e.errno})')
                self.last_error = None
                self.state = UnixConnection.State.finished
                self.ev_updated.set()
                break
            except asyncio.CancelledError as e:
                log.debug(f'{self.sock_path}: Handler cancelled')
                break
            except OSError as e:
                if str(e) != str(self.last_error):
                    log.debug(f'{self.sock_path}: {e.strerror} (Error {e.errno})')
                self.last_error = e
                if self.state != UnixConnection.State.disconnected:
                    log.debug(f'{self.sock_path}: Reconnecting...')
                    self.state = UnixConnection.State.disconnected
                self.ev_updated.set()
                await asyncio.sleep(1)

    def stat(self):
        lp = self.last_progress
        if self.state == UnixConnection.State.finished:
            led = '[green]●[/]'
        elif self.state == UnixConnection.State.connected:
            led = '[yellow]●[/]'
        elif lp:
            led = '[red]●[/]'
        else:
            led = '[gray]●[/]'

        state_info = ''
        if self.state == UnixConnection.State.finished and lp and lp.wallclock_time:
            state_info = 'Finished ' + lp.wallclock_time.strftime('%Y-%m-%d %H:%M:%S')
        if self.last_error:
            state_info = self.last_error.strerror
            if lp and lp.wallclock_time:
                state_info += ' since ' + lp.wallclock_time.strftime('%Y-%m-%d %H:%M:%S')

        return dict(
            percent=lp and lp.simulation_percent,
            time=lp and lp.simulation_time,
            led=led,
            caption=lp and lp.caption or self.sock_path,
            vortex_count=lp and lp.vortex_count,
            step_duration=lp and lp.step_duration,
            elapsed=lp and lp.elapsed,
            remains=lp and lp.remains,
            eta=lp and lp.eta,
            state=state_info,
        )


class LiveTable():
    all_columns = dict(
        percent='%',
        time='Time  ',
        led='○',
        caption='Caption',
        vortex_count='Vortex count',
        step_duration='Step duration',
        elapsed='Time elapsed',
        remains='Time remains',
        eta='ETA',
        state='State'
    )

    def __init__(self, console, all_columns: bool = False):
        self.columns = [x for x in [
            'percent',
            'time',
            'led',
            'caption',
            'vortex_count' if all_columns else None,
            'step_duration' if all_columns else None,
            'elapsed',
            'remains',
            'eta',
            'state'
        ] if x is not None]
        self.ev_updated = asyncio.Event()
        self.conn_pool = {}
        self.console = console

    async def watch_dir(self, workdir):
        while True:
            try:
                sock_list = [f for f in os.listdir(workdir) if f.endswith('.sock')]
                for sock_path in sock_list:
                    if conn:= self.conn_pool.get(sock_path):
                        if conn.state == UnixConnection.State.finished:
                            await conn.task
                            del self.conn_pool[sock_path]
                        else:
                            continue

                    conn = UnixConnection(sock_path, self.ev_updated)
                    self.conn_pool[sock_path] = conn
                    conn.task = asyncio.create_task(conn.handle())
                    self.ev_updated.set()
                await asyncio.sleep(1)
            except asyncio.CancelledError as e:
                break

    async def wait_updated(self, timeout):
        try:
            await asyncio.wait_for(self.ev_updated.wait(), timeout)
        except asyncio.TimeoutError:
            pass
        self.ev_updated.clear()

    def render(self):
        table = Table(box=box.SIMPLE)
        for col in self.columns:
            table.add_column(LiveTable.all_columns.get(col))

        sim_running = 0
        sim_total = len(self.conn_pool)
        for sock_path in sorted(self.conn_pool):
            conn = self.conn_pool[sock_path]
            conn_stat = conn.stat()
            fields = [str(conn_stat.get(col) or '') for col in self.columns]
            table.add_row(*fields)
            if conn.state == UnixConnection.State.connected:
                sim_running += 1

        now = datetime.now()
        datestr = now.strftime('%Y-%m-%d')
        timestr = now.strftime('%H:%M:%S')
        footer = f"\[{datestr} [bold]{timestr}[/]]"
        footer += f"\n{sim_running:3d} running"
        footer += f"\n{sim_total:3d} total"
        return Group(table, footer)


async def main():
    loop = asyncio.get_running_loop()
    def loop_stop():
        loop.stop()
        raise KeyboardInterrupt
    loop.add_signal_handler(signal.SIGINT, loop_stop)
    loop.add_signal_handler(signal.SIGTERM, loop_stop)

    args = parse_args()
    console = Console(highlight=False)
    logging.basicConfig(
        level=logging.INFO,
        format="%(message)s",
        datefmt="[%X]",
        handlers=[RichHandler(highlighter=NullHighlighter(), console=console)],
    )

    global log
    log = logging.getLogger()
    log.setLevel(logging.DEBUG if args.debug else logging.INFO)

    live_table = LiveTable(console=console, all_columns=args.all_columns)
    asyncio.create_task(live_table.watch_dir(args.workdir))

    with Live(live_table.render(), auto_refresh=False, console=console) as live:
        while True:
            await live_table.wait_updated(timeout=1)
            live.update(live_table.render(), refresh=True)
            await asyncio.sleep(0.25)


if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
