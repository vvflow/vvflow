#!/usr/bin/env python3

from __future__ import print_function
from dataclasses import dataclass
from datetime import datetime
from enum import auto, Enum
from subprocess import Popen, PIPE
import argparse
import asyncio
import errno
import logging
import os
import signal

from rich import box
from rich.live import Live
from rich.logging import RichHandler
from rich.highlighter import NullHighlighter
from rich.table import Table


logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(highlighter=NullHighlighter())],
)
log = logging.getLogger()


def parse_args():
    parser = argparse.ArgumentParser(
        prog='vvmon',
        description='Monitor simulation progress',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        'workdir',
        nargs='?',
        default='.',
        help='Simulation working directory to monitor'
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help='Print debug logs'
    )

    return parser.parse_args()


@dataclass
class SimulationProgress():
    caption: str
    wallclock_time: datetime
    simulation_time: float | None
    simulation_percent: int | None
    # steps_per_second: float
    vortex_count: int | None


class UnixConnection():
    class State(Enum):
        disconnected = auto()
        connected = auto()
        finished = auto()

    def __init__(self, sock_path, ev_updated):
        self.sock_path = sock_path
        self.finished = False
        self.last_error = None
        self.last_progress = None
        self.state = UnixConnection.State.disconnected
        self.ev_updated = ev_updated

    @staticmethod
    def decode_message(msg):
        ret = {}
        for field in msg.decode().split():
            key, val = field.split('=', 1)
            ret[key] = val
        return ret

    async def handle(self):
        log.debug(f'{self.sock_path}: Connecting...')
        while True:
            try:
                sock_reader, sock_writer = await asyncio.open_unix_connection(self.sock_path)
                log.debug(f'{self.sock_path}: Connected')
                self.state = UnixConnection.State.connected
                self.last_error = None
                self.last_progress = None
                self.ev_updated.set()
                while True:
                    msg = await sock_reader.read(1024)
                    if not len(msg):
                        sock_writer.close()
                        raise OSError(errno.ECONNRESET, "Connection reset by peer")
                    keyval = UnixConnection.decode_message(msg)
                    self.last_progress = SimulationProgress(
                        caption=self.sock_path,
                        wallclock_time=datetime.now(),
                        simulation_time=keyval['t'],
                        simulation_percent=0,
                        vortex_count=keyval['N'],
                    )
                    self.ev_updated.set()
            except FileNotFoundError as e:
                log.debug(f'{self.sock_path}: {e.strerror} (Error {e.errno})')
                self.last_error = None
                self.state = UnixConnection.State.finished
                self.ev_updated.set()
                break
            except asyncio.CancelledError as e:
                log.debug(f'{self.sock_path}: Handler cancelled')
                break
            except OSError as e:
                if str(e) != str(self.last_error):
                    log.debug(f'{self.sock_path}: {e.strerror} (Error {e.errno})')
                self.last_error = e
                if self.state != UnixConnection.State.disconnected:
                    log.debug(f'{self.sock_path}: Reconnecting...')
                    self.state = UnixConnection.State.disconnected
                self.ev_updated.set()
                await asyncio.sleep(1)

    def render(self):
        lp = self.last_progress
        if self.state == UnixConnection.State.finished:
            led = '[green]●[/]'
        elif self.state == UnixConnection.State.connected:
            led = '[yellow]●[/]'
        elif lp:
            led = '[red]●[/]'
        else:
            led = '[gray]●[/]'

        return (
            str(lp and lp.simulation_percent or ''),
            str(lp and lp.simulation_time or ''),
            led,
            str(lp and lp.caption or self.sock_path),
            str(lp and lp.vortex_count or ''),
            str(self.last_error and self.last_error.strerror or ''),
        )


class LiveTable():
    def __init__(self):
        self.ev_updated = asyncio.Event()
        self.conn_pool = {}

    async def watch_dir(self, workdir):
        while True:
            try:
                sock_list = [f for f in os.listdir(workdir) if f.endswith('.sock')]
                for sock_path in sock_list:
                    if conn:= self.conn_pool.get(sock_path):
                        if conn.state == UnixConnection.State.finished:
                            await conn.task
                            del self.conn_pool[sock_path]
                        else:
                            continue

                    conn = UnixConnection(sock_path, self.ev_updated)
                    self.conn_pool[sock_path] = conn
                    conn.task = asyncio.create_task(conn.handle())
                    self.ev_updated.set()
                await asyncio.sleep(1)
            except asyncio.CancelledError as e:
                break

    async def wait_updated(self):
        await self.ev_updated.wait()
        self.ev_updated.clear()

    def render(self):
        table = Table(box=box.SIMPLE)
        table.add_column("%")
        table.add_column("Time  ")
        table.add_column("○")
        table.add_column("Caption")
        table.add_column("Vortex count")
        table.add_column("Error")

        for sock_path in sorted(self.conn_pool):
            conn = self.conn_pool[sock_path]
            table.add_row(*conn.render())

        return table


async def main():
    loop = asyncio.get_running_loop()
    def loop_stop():
        loop.stop()
        raise KeyboardInterrupt
    loop.add_signal_handler(signal.SIGINT, loop_stop)
    loop.add_signal_handler(signal.SIGTERM, loop_stop)

    args = parse_args()
    log.setLevel(logging.DEBUG if args.debug else logging.INFO)
    live_table = LiveTable()
    asyncio.create_task(live_table.watch_dir(args.workdir))
    with Live(live_table.render(), auto_refresh=False) as live:
        while True:
            await live_table.wait_updated()
            live.update(live_table.render(), refresh=True)


if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
